from typing import Callable
import numpy as np

from multiprocessing.pool import ThreadPool


def compute_np_screen(
    func: Callable[[complex], int],
    width: int,
    height: int,
    screen: np.ndarray,
    screen_buffer: np.ndarray,
    *,
    scale_x: float = 1,
    scale_y: float = 1,
    shift_x: float = 0,
    shift_y: float = 0,
    max_value: int = 16,
    reverse_color: bool = False,
    channel: int = 0,
):
    """
    Computes a screen representation of a function over a complex plane.

    Args:
        func (:obj:`Callable[[complex], int]`):
            A function that maps complex numbers to integers, defining the
            behavior of the screen representation. Usually it is one of from iterative
            root finding methods.
        width (int):
            Width of the screen.
        height (int):
            Height of the screen.
        screen (:obj:`numpy.ndarray`):
            Screen array to store the resulting representation.
        screen_buffer (:obj:`numpy.ndarray`):
            Temporary buffer array for intermediate calculations.
        scale_x (float, optional):
            Scaling factor for the x-axis. Defaults to 1.
        scale_y (float, optional):
            Scaling factor for the y-axis. Defaults to 1.
        shift_x (float, optional):
            Shift value for the x-axis. Defaults to 0.
        shift_y (float, optional):
            Shift value for the y-axis. Defaults to 0.
        max_value (int, optional):
            Maximum value used for color mapping. Defaults to 16.
        reverse_color (bool, optional):
            Flag to reverse the color mapping. Defaults to False.
        channel (int, optional):
            Color channel for color mapping. Defaults to 0.

    Returns:
        :obj:`numpy.ndarray`:
            The resulting screen representation based on the provided function
            over the complex plane.

    Note:
        - The screen representation is generated by applying the `func` to each
          point on the complex plane defined by the width and height of the
          screen.
        - The resulting integer values from the `func` are mapped to colors on
          the screen based on the provided color mapping parameters.
        - The input screen and screen_buffer arrays are modified in-place.
        - The function assumes that the input screen and screen_buffer arrays
          have the correct shape and dtype.
        - The color values are scaled to the range [0, 255].

    """
    assert len(screen.shape) >= 3, "Wrong shape for screen"
    assert len(screen_buffer.shape) >= 3, "Wrong shape for screen buffer"
    assert screen.shape == screen_buffer.shape, "screen shape != screen buffer shape"
    origin_x = width / 2
    origin_y = height / 2
    for j in range(height):
        for i in range(width):
            x = (i - origin_x) * scale_x + shift_x
            y = -(j - origin_y) * scale_y + shift_y
            val = complex(x, y)
            res = func(val)
            screen_buffer[j, i, channel] = max_value - res if reverse_color else res
    screen[:, :, 0] = screen_buffer[:, :, 0] / max_value * 255
    screen[:, :, 1] = screen_buffer[:, :, 1] / max_value * 255
    screen[:, :, 2] = screen_buffer[:, :, 2] / max_value * 255
    if screen.shape[2] > 3:
        screen[:, :, 3] = screen_buffer[:, :, 3] / max_value * 255
    return np.flipud(screen)


def compute_np_screen_multithread(
    func: Callable[[complex], int],
    width: int,
    height: int,
    screen: np.ndarray,
    screen_buffer: np.ndarray,
    *,
    scale_x: float = 1,
    scale_y: float = 1,
    shift_x: float = 0,
    shift_y: float = 0,
    max_value: int = 16,
    reverse_color: bool = False,
    channel: int = 0,
    thread_count: int = 16,
):
    """
    Computes a screen representation of a function over a complex plane using
    multiple threads.

    Args:
        func (:obj:`Callable[[complex], int]`):
            A function that maps complex numbers to integers, defining the
            behavior of the screen representation.
        width (int):
            Width of the screen.
        height (int):
            Height of the screen.
        screen (:obj:`numpy.ndarray`):
            Screen array to store the resulting representation.
        screen_buffer (:obj:`numpy.ndarray`):
            Temporary buffer array for intermediate calculations.
        scale_x (float, optional):
            Scaling factor for the x-axis. Defaults to 1.
        scale_y (float, optional):
            Scaling factor for the y-axis. Defaults to 1.
        shift_x (float, optional):
            Shift value for the x-axis. Defaults to 0.
        shift_y (float, optional):
            Shift value for the y-axis. Defaults to 0.
        max_value (int, optional):
            Maximum value used for color mapping. Defaults to 16.
        reverse_color (bool, optional):
            Flag to reverse the color mapping. Defaults to False.
        channel (int, optional):
            Color channel for color mapping. Defaults to 0.
        thread_count (int, optional):
            Number of threads to use for parallel computation. Defaults to 16.

    Returns:
        :obj:`numpy.ndarray`:
            The resulting screen representation based on the provided function
            over the complex plane.

    Note:
        - The screen representation is generated by applying the `func` to each
          point on the complex plane defined by the width and height of the
          screen.
        - The resulting integer values from the `func` are mapped to colors on
          the screen based on the provided color mapping parameters.
        - The input screen and screen_buffer arrays are modified in-place.
        - The function assumes that the input screen and screen_buffer arrays
          have the correct shape and dtype.
        - The color values are scaled to the range [0, 255].
        - The computation is performed using multiple threads to speed up the
          process. The `thread_count` parameter controls the number of threads
          to use.

    """
    assert len(screen.shape) >= 3, "Wrong shape for screen"
    assert len(screen_buffer.shape) >= 3, "Wrong shape for screen buffer"
    assert screen.shape == screen_buffer.shape, "screen shape != screen buffer shape"
    origin_x = width / 2
    origin_y = height / 2

    def set_pixel(val: complex):
        res = func(val)
        screen_buffer[j, i, channel] = max_value - res if reverse_color else res
        return None

    with ThreadPool(thread_count) as pool:
        vals: list[complex] = []
        for i in range(width):
            for j in range(height):
                x = (i - origin_x) * scale_x + shift_x
                y = -(j - origin_y) * scale_y + shift_y
                val = complex(x, y)
                vals.append(val)
        pool.map(set_pixel, vals)

    screen[:, :, 0] = screen_buffer[:, :, 0] / max_value * 255
    screen[:, :, 1] = screen_buffer[:, :, 1] / max_value * 255
    screen[:, :, 2] = screen_buffer[:, :, 2] / max_value * 255
    if screen.shape[2] > 3:
        screen[:, :, 3] = screen_buffer[:, :, 3] / max_value * 255
    return np.flipud(screen)


def compute_np_screen_vectorized(
    func: Callable[[np.ndarray], np.ndarray],
    width: int,
    height: int,
    screen: np.ndarray,
    screen_buffer: np.ndarray,
    *,
    scale_x: float = 1,
    scale_y: float = 1,
    shift_x: float = 0,
    shift_y: float = 0,
    max_value: int = 16,
    reverse_color: bool = False,
    channel: int = 0,
):
    """
    Computes a screen representation of a function over a complex plane.

    Args:
        func (:obj:`Callable[[np.ndarray], int]`):
            A function that maps an ndarray of complex numbers to an ndarray
            of integers, defining the behavior of the screen representation.
        width (int):
            Width of the screen.
        height (int):
            Height of the screen.
        screen (:obj:`numpy.ndarray`):
            Screen array to store the resulting representation.
        screen_buffer (:obj:`numpy.ndarray`):
            Temporary buffer array for intermediate calculations.
        scale_x (float, optional):
            Scaling factor for the x-axis. Defaults to 1.
        scale_y (float, optional):
            Scaling factor for the y-axis. Defaults to 1.
        shift_x (float, optional):
            Shift value for the x-axis. Defaults to 0.
        shift_y (float, optional):
            Shift value for the y-axis. Defaults to 0.
        max_value (int, optional):
            Maximum value used for color mapping. Defaults to 16.
        reverse_color (bool, optional):
            Flag to reverse the color mapping. Defaults to False.
        channel (int, optional):
            Color channel for color mapping. Defaults to 0.

    Returns:
        :obj:`numpy.ndarray`:
            The resulting vectorized screen representation based on the
            provided function over the complex plane.

    Note:
        - The `func` argument should be a callable that takes an ndarray of
          complex numbers as input and returns an ndarray of integers.
        - The screen representation is generated by applying the `func` to the screen
        - The resulting integer values from the `func` are mapped to colors on
          the screen based on the provided color mapping parameters.
        - The input screen and screen_buffer arrays are modified in-place.
        - The function assumes that the input screen and screen_buffer arrays
          have the correct shape and dtype.
        - The computation is vectorized for faster execution using NumPy
          operations.
        - The resulting screen representation is stored in the `screen` array.
        - The color values are scaled to the range [0, 255].
    """
    assert len(screen.shape) >= 3, "Wrong shape for screen"
    assert len(screen_buffer.shape) >= 3, "Wrong shape for screen buffer"
    assert screen.shape == screen_buffer.shape, "screen shape != screen buffer shape"
    origin_x = width / 2
    origin_y = height / 2
    for j in range(height):
        for i in range(width):
            x = (i - origin_x) * scale_x + shift_x
            y = -(j - origin_y) * scale_y + shift_y
            val = complex(x, y)
            screen_buffer[j, i, channel] = val
    iter_counts = func(screen_buffer[:, :, channel])
    screen_buffer[:, :, channel] = iter_counts
    if reverse_color:
        screen_buffer[:, :, channel] = max_value - screen_buffer[:, :, channel]
    screen[:, :, 0] = (screen_buffer[:, :, 0] / max_value * 255).real
    screen[:, :, 1] = (screen_buffer[:, :, 1] / max_value * 255).real
    screen[:, :, 2] = (screen_buffer[:, :, 2] / max_value * 255).real
    if screen.shape[2] > 3:
        screen[:, :, 3] = (screen_buffer[:, :, 3] / max_value * 255).real
    return np.flipud(screen)
